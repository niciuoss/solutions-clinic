# Relatório de Análise de Vulnerabilidades — API Solutions Clinic

**Data:** 08/02/2025  
**Escopo:** `API/solutions-clinic/`  
**Metodologia:** OWASP Top 10:2025, mapeamento de superfície de ataque, priorização de risco

---

## 1. Resumo Executivo

A API é uma aplicação Spring Boot (Java) com JWT (HS256/OIDC), multi-tenant, integração Stripe e PostgreSQL. A análise identificou **controle de acesso quebrado (IDOR e cross-tenant)** como risco principal, **secretos com valores padrão em repositório** e **falta de validação de ordenação** em alguns endpoints. O webhook do Stripe está corretamente validado; não há indícios de injeção SQL nas consultas analisadas.

| Severidade | Quantidade |
|------------|------------|
| Crítica    | 1          |
| Alta       | 2          |
| Média      | 3          |
| Baixa      | 2          |

---

## 2. Superfície de Ataque Mapeada

| Categoria       | Elementos |
|-----------------|-----------|
| **Entradas**    | REST `/v1/*` (auth, patients, appointments, professionals, financial, subscriptions, tenants, users, rooms, procedures, signup), webhook `/v1/subscriptions/webhook`, Swagger `/swagger-ui/**`, `/v3/api-docs/**` |
| **Autenticação**| JWT (HS256 ou JWK), sign-in `/v1/auth/sign-in`, stateless |
| **Autorização** | Nenhuma verificação de tenant/permissão além do “authenticated” global |
| **Dados sensíveis**| Pacientes (CPF, contato), agendamentos, financeiro, usuários, assinaturas Stripe |

---

## 3. Vulnerabilidades Identificadas

### 3.1 [CRÍTICA] Controle de acesso quebrado — IDOR e cross-tenant (A01)

**O quê:** Qualquer usuário autenticado pode acessar e alterar recursos de **qualquer tenant** (clínica). Não há checagem entre o `tenantId`/`clinicId` do JWT e o recurso solicitado.

**Onde:**
- **Por ID (IDOR):**
  - `DefaultGetPatientByIdUseCase` — `GET /v1/patients/{id}` retorna qualquer paciente por UUID.
  - `DefaultGetAppointmentByIdUseCase` — `GET /v1/appointments/{id}` retorna qualquer agendamento.
  - `DefaultUpdatePatientActiveUseCase` — `PATCH /v1/patients/{id}` ativa/desativa qualquer paciente.
  - `DefaultGetProcedureByIdUseCase`, `DefaultGetRoomByIdUseCase`, `DefaultGetUserByIdUseCase`, etc. — mesmo padrão por ID sem verificação de tenant.
- **Por tenantId informado pelo cliente (cross-tenant):**
  - `GetPatientsByTenantUseCase`, `GetAppointmentsByTenantUseCase`, `GetFinancialTransactionsByTenantUseCase`, `GetRoomsByTenantUseCase`, `GetProceduresByTenantUseCase`, `GetUsersByTenantUseCase`, `GetProfessionalsByClinicUseCase`, etc.
  - O `tenantId`/`clinicId` vem do path ou query; **nunca** é comparado com o tenant do JWT (claim `clinicId`).
- **Criação em tenant arbitrário:**
  - `DefaultCreatePatientUseCase` aceita `tenantId` no body; qualquer usuário pode criar paciente em qualquer clínica.
  - Padrão similar em criação de rooms, procedures, categorias financeiras, transações, etc.

**Por quê:** A aplicação confia no “authenticated” do Spring Security e no `tenantId`/ID enviados pelo cliente, sem camada de autorização por tenant ou por recurso.

**Impacto:** Vazamento e alteração de dados entre clínicas (pacientes, agendamentos, financeiro, usuários), violação de isolamento multi-tenant e possíveis requisitos legais (LGPD).

**Como corrigir:**
1. Extrair `clinicId` (ou lista de tenants permitidos) do JWT em um filtro/interceptor ou serviço compartilhado.
2. Em todos os use cases que recebem `tenantId`/`clinicId` ou IDs de entidades:
   - Validar que o tenant do recurso é um dos permitidos para o usuário autenticado.
   - Para operações por ID (get/update/delete), carregar a entidade e checar `entity.getTenant().getId()` contra o contexto do usuário.
3. Em criações, ignorar `tenantId` do body e usar apenas o tenant do contexto (JWT), ou validar que o usuário pertence ao tenant informado.
4. Opcional: usar `@PreAuthorize` ou método de autorização centralizado (ex.: “user can access tenant X”) para deixar a política explícita.

---

### 3.2 [ALTA] Secretos com valores padrão no repositório (A02 / A05)

**O quê:** Valores padrão de secretos sensíveis estão definidos em `application.yaml` e em `.env.example`, incluindo chave JWT e webhook Stripe.

**Onde:**
- `src/main/resources/application.yaml`:
  - `security.token.secret`: `my-super-secret-key-for-development-only-min-32-chars`
  - `stripe.webhook.secret`: `whsec_64d9394c2cb4ce231ed67df18d6484c45cdf5bf837213330244781ca1bf0140d`
- `.env.example`: `SECURITY_TOKEN_SECRET=...` (mesmo valor de desenvolvimento).

**Por quê:** Facilitar desenvolvimento sem variáveis de ambiente; em produção, se as variáveis não forem definidas, esses valores são usados.

**Impacto:** Em produção com defaults: forjamento de JWT, bypass de autenticação e possível aceitação de webhooks Stripe falsos (se o secret real não for configurado).

**Como corrigir:**
1. Remover **qualquer** valor padrão de `security.token.secret` e `stripe.webhook.secret` em `application.yaml`. Ex.: usar apenas `${SECURITY_TOKEN_SECRET}` e `${STRIPE_WEBHOOK_SECRET}` e falhar na inicialização se vazios.
2. Em `.env.example`, manter apenas nomes das variáveis, sem valores reais (ex.: `SECURITY_TOKEN_SECRET=` e comentário “obrigatório em produção”).
3. Garantir que em produção os secretos vêm de variáveis de ambiente ou de um secrets manager (ex.: AWS Secrets Manager, Vault).

---

### 3.3 [ALTA] Webhook Stripe sem header obrigatório tratado graciosamente

**O quê:** O endpoint declara `@RequestHeader("Stripe-Signature") String signature` como obrigatório. Se o header for omitido, o Spring retorna 400 antes do controller; não é um problema de lógica, mas a mensagem pode expor que o endpoint existe. O uso case já valida a assinatura com `Webhook.constructEvent()` e lança `InvalidRequestException` em falha — **comportamento correto**.

**Onde:** `SubscriptionAPI.handleWebhook`, `DefaultProcessStripeWebhookUseCase`.

**Recomendação (baixo impacto):** Manter header obrigatório. Em ambientes sensíveis, considerar rate limiting e monitoração de tentativas de chamada sem assinatura. Nenhuma alteração crítica necessária na validação do webhook.

---

### 3.4 [MÉDIA] Parâmetro de ordenação (sort) sem whitelist — Pacientes e Procedimentos (A03 / A10)

**O quê:** O parâmetro `sort` é passado diretamente para `Sort.by(direction, field)` sem validar o nome do campo. Em Pacientes e Procedimentos o “field” é controlado pelo cliente.

**Onde:**
- `DefaultGetPatientsByTenantUseCase.createPageable()` — usa `field` do request em `Sort.by(sortDirection, field)`.
- `DefaultGetProceduresByTenantUseCase.createPageable()` — mesmo padrão.

**Por quê:** Flexibilidade de ordenação sem lista de campos permitidos.

**Impacto:** Risco de ordenação por propriedades internas (ex.: caminhos de entidade) ou comportamento inesperado/erro; em cenários extremos, possível uso em ataques de enumeração ou abuso de recursos. Não há concatenação SQL; as queries usam JPQL parametrizado.

**Como corrigir:** Seguir o padrão já usado em `DefaultGetUsersByTenantUseCase` e `DefaultGetProfessionalsByClinicUseCase`: mapear `sort` para uma whitelist de campos (ex.: `firstName`, `createdAt`, `cpf`, etc.) e usar apenas esses nomes em `Sort.by()`.

---

### 3.5 [MÉDIA] Tratamento genérico de RuntimeException (A10)

**O quê:** `GlobalExceptionHandler` captura `RuntimeException` e retorna mensagem genérica ao cliente, o que é bom para não vazar detalhes. Porém, qualquer exceção não mapeada (incluindo algumas de segurança ou de bibliotecas) cai nesse handler.

**Onde:** `GlobalExceptionHandler.handleRuntimeException(RuntimeException ex)`.

**Impacto:** Evita vazamento de stack trace na resposta (positivo). O risco é mascarar falhas que deveriam ser tratadas de forma específica (ex.: `SignatureVerificationException` já é convertida em `InvalidRequestException` no use case, então está ok). Manter registro em log com nível adequado para auditoria.

**Recomendação:** Manter resposta genérica; garantir que exceções de segurança (ex.: falha de assinatura JWT) não sejam apenas “500 genérico” no log — já está tratado no fluxo do webhook. Revisar logs para não gravar dados sensíveis (tokens, PII).

---

### 3.6 [MÉDIA] CORS restrito a localhost

**O quê:** CORS permite apenas `http://localhost:*` e `http://127.0.0.1:*`.

**Onde:** `SecurityConfig.corsConfigurationSource()`.

**Impacto:** Em produção, se `FRONTEND_URL` não for configurado como origem permitida, o front em outro domínio será bloqueado pelo navegador. Não é vulnerabilidade de segurança, mas falha de configuração esperada em produção.

**Como corrigir:** Em produção, usar `app.frontend.url` (ou equivalente) para definir as origens permitidas, sem usar `*` em ambiente produtivo. Manter credenciais e métodos/headers necessários.

---

### 3.7 [BAIXA] CSRF desabilitado

**O quê:** `http.csrf(csrf -> csrf.disable())` na configuração de segurança.

**Onde:** `SecurityConfig.securityFilterChain()`.

**Contexto:** Para API REST stateless com JWT em header (não cookie), a ausência de CSRF é aceitável, pois não há sessão baseada em cookie que um site malicioso pudesse reutilizar.

**Recomendação:** Manter CSRF desabilitado para esta API; documentar a decisão. Se no futuro houver uso de cookies de sessão, reavaliar.

---

### 3.8 [BAIXA] Swagger/OpenAPI público

**O quê:** `/swagger-ui/**` e `/v3/api-docs/**` estão em `permitAll()`.

**Onde:** `SecurityConfig`, `OpenApiConfig`.

**Impacto:** Em produção, a documentação da API fica acessível a qualquer um, expondo rotas e contratos. Facilita reconhecimento para um atacante.

**Recomendação:** Em produção, restringir acesso ao Swagger (por exemplo, apenas para IPs de rede interna ou com autenticação básica), ou desabilitar em profile de produção.

---

## 4. Pontos Positivos

- **Webhook Stripe:** Assinatura verificada com `Webhook.constructEvent()`; falha lança `InvalidRequestException`. Payload não é processado sem assinatura válida.
- **Senha:** Uso de `BCryptPasswordEncoder` para hash de senhas.
- **JWT:** Suporte a HS256 com secret mínimo de 32 caracteres e a JWK (OIDC); validação de issuer e audience quando configurados.
- **Queries:** Uso de JPQL com parâmetros nomeados (ex.: `PatientRepository.findByTenantIdWithFilters`); não foi encontrada concatenação de SQL com entrada do usuário.
- **Respostas de erro:** `GlobalExceptionHandler` não expõe stack trace nem mensagens internas ao cliente.
- **Validação de entrada:** Uso de `@Valid` e Bean Validation nos bodies de request.
- **Alguns use cases:** `DefaultGetUsersByTenantUseCase` e `DefaultGetProfessionalsByClinicUseCase` já utilizam whitelist para o parâmetro de ordenação.

---

## 5. Checklist OWASP (resumido)

| Categoria              | Status | Observação |
|------------------------|--------|------------|
| A01 Broken Access Control | ❌ | IDOR e cross-tenant; sem checagem tenant vs JWT |
| A02 Cryptographic Failures | ⚠️ | Secretos com default no repo; senhas com bcrypt ok |
| A03 Injection           | ✅ | JPQL parametrizado; sem concatenação de SQL |
| A05 Security Misconfiguration | ⚠️ | Defaults de secretos; CORS/Swagger para produção |
| A07 Authentication Failures | ✅ | JWT validado; sign-in com senha hasheada |
| A09 Logging & Alerting  | ⚠️ | Revisar para não logar tokens/PII |
| A10 Exceptional Conditions | ⚠️ | RuntimeException genérico ok; garantir fail-closed em auth |

---

## 6. Priorização de Remediação

1. **Imediato (crítico):** Implementar autorização por tenant em todos os endpoints (recursos por ID e listagens/criações por tenant). Garantir que `tenantId`/`clinicId` do contexto (JWT) seja a única fonte de verdade para “tenant do usuário” e que todos os acessos a dados validem contra ela.
2. **Curto prazo (alto):** Remover valores padrão de secretos em `application.yaml` e `.env.example`; falhar no boot se variáveis obrigatórias não estiverem definidas em produção.
3. **Médio prazo (médio):** Whitelist de `sort` em Pacientes e Procedimentos; ajustar CORS e visibilidade do Swagger para produção; revisar logs (sem PII/tokens).
4. **Contínuo:** Manter dependências atualizadas (ex.: `./gradlew dependencyCheck` ou similar); repetir esta análise após mudanças de autorização e novos endpoints.

---

## 7. Referências

- OWASP Top 10 2025  
- Skill: vulnerability-scanner (checklists e metodologia)  
- Código analisado: `API/solutions-clinic/` (security, web, usecases, repositories, application.yaml)
